<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: devops | EngineerInk]]></title>
  <link href="http://technology.customink.com/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://technology.customink.com/"/>
  <updated>2012-06-12T18:42:22-04:00</updated>
  <id>http://technology.customink.com/</id>
  <author>
    <name><![CDATA[CustomInk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introducing Stoplight: Greenscreen 2.0]]></title>
    <link href="http://technology.customink.com/blog/2012/06/12/introducing-stoplight-greenscreen-2-dot-0/"/>
    <updated>2012-06-12T17:48:00-04:00</updated>
    <id>http://technology.customink.com/blog/2012/06/12/introducing-stoplight-greenscreen-2-dot-0</id>
    <content type="html"><![CDATA[<p><a href="http://technology.customink.com/images/stoplight.png"><img src="http://technology.customink.com/images/stoplight.png" width="300" style="float:right; margin:0 0 15px 15px;" /></a>
At CustomInk, we use a variety of tools to monitor the status of our builds. One such tool was <a href="https://github.com/customink-webops/greenscreen">Greenscreen</a>. In fact, we even wrote <a href="http://technology.customink.com/blog/2012/01/02/green-screen/">a blog post about how we use Greenscreen at CustomInk</a> not too long ago.</p>

<p>One of the biggest problems with Greenscreen was its extensibility. By default, Greenscreen only works with Hudson and Jenkins servers. With <a href="http://travis-ci.org">Travis CI</a> becoming quite popular in the open-source community, Greenscreen needed a major upgrade. Furthermore, Greenscreen was not very extensible.</p>

<p>After some significant refactoring, Greenscreen evolved into <a href="https://github.com/customink/stoplight">Stoplight</a>...</p>

<!-- more -->


<h2>Significant Improvements</h2>

<p>There are a number of improvements in Stoplight. These are the most critical or useful to the end-user:</p>

<ul>
<li>Support for multiple (any) continuous integration server</li>
<li>Highly configurable yaml files</li>
<li>Cross-browser beautiful UI</li>
<li>More informative build statuses</li>
<li>Extensibility</li>
<li>Usability</li>
<li>Full test suite</li>
</ul>


<h2>Refactoring</h2>

<p>Originally, I was just going to add Travis CI support to Greenscreen. However, I quickly asked myself, "why stop at Travis CI?"; we should allow developers to connect Greenscreen to any continuous integration server. After cleaning up the code a bit, I introduced the concept of a <code>Provider</code>. Simply put, a <code>Provider</code> is an abstract Ruby class that maps server-data into Greenscreen data. It looks like this:</p>

<p>```ruby</p>

<h1>Provider is an abstract class that all providers inherit from. It requires that a specified format be returned. This way, stoplight</h1>

<h1>doesn't care who it's talking to, as long as it guarantees certain information.</h1>

<p>module Stoplight::Providers
  class Provider</p>

<pre><code>attr_reader :options, :response

# Initializes a hash `@options` of default options
def initialize(options = {})
  ...
end

# `projects` must return an array of Stoplight::Project
# see Stoplight::Project for more information on the spec
def projects
  ...
end
</code></pre>

<p>  end
end
```</p>

<p>On the front-end, now we don't have to worry about parsing different server responses; we know that any provider will respond to the <code>Provider#projects</code> instance method. This makes refactoring our front-end code much easier.</p>

<p>The <code>Stoplight::Project</code> clearly defines a schema and method-set that must be adhered to. In the front-end, we can simply call <code>.projects</code> on any provider and know with 100% certainty that the given objects respond to a certain set of methods. Those methods are defined in the <code>Stoplight::Project</code> class:</p>

<p>```ruby
module Stoplight
  class Project</p>

<pre><code>attr_accessor :name, :build_url, :last_build_id, :last_build_time, :last_build_status, :current_status

# Initialize (new) takes in a hash of options in the following format:
#
# {
#   :name =&gt; 'my_project',
#   :build_url =&gt; 'http://ci.jenkins.org/job/my_project',
#   :web_url =&gt; 'http://github.com/username/my_project', # optional
#   :last_build_id =&gt; '7',
#   :last_build_time =&gt; '2012-05-24T03:19:53Z',
#   :last_build_status =&gt; 0,
#   :current_status =&gt; 1,
# }
#
# - `name` - the name of this project
# - `build_url` - the url where the build came from
# - `build_id` - the unique build_id for this project
# - `last_build_time` - last successful build
# - `last_build_status` - integer representing the exit code of the last build:
#   - -1: unknown
#   -  0: passed (success)
#   -  1: failed (error, failure)
# - `current_status` - the current status of the build:
#   - -1: unknwon
#   -  0: done (sleeping, waiting)
#   -  1: building (building, working, compiling)
def initialize(options = {})
  ...
end
</code></pre>

<p>  end
end
<code>``
This set of simple instructions tells a provider how it must format data. Essentially this makes</code>Provider` a micro-data-mapper, massaging data from remote APIs into a standard format. Stoplight then uses that standard format to create a unified user experience.</p>

<h3>Adding Tests</h3>

<p>Since Stoplight is destined to become an open-source project, it needs a comprehensive test suite. Furthermore, during our refactoring, it's important that we don't break existing functionality. As such, I added a full test suite with RSpec. To make development easier, I also use Spork, Guard, and Growl-Ruby to automatically run tests in the background while I'm coding. This makes TDD much more exciting.</p>

<h3>Foreman</h3>

<p>With all those dependencies, plus running the server, it only made sense to use <a href="https://github.com/ddollar/foreman">Foreman</a> to manage all those processes. What used to be (in three different terminal tabs):</p>

<pre><code>bundle exec shotgun -p 4567
bundle exec compass watch -c config/compass.rb
bundle exec guard
</code></pre>

<p>simply became:</p>

<pre><code>bundle exec foreman start
</code></pre>

<p>with a tiny <code>Procfile</code>:</p>

<p><code>
web:      shotgun -p 4567
compass:  compass watch -c config/compass.rb
guard:    guard
</code></p>

<h3>Compass</h3>

<p>Under the hood, all the styles for Stoplight are generated by a framework called <a href="http://compass-style.org">Compass</a>. Compass allows us to leverage the power of SCSS and easily create a cross-browser compliant application. Stoplight uses Compass and SCSS for all it's styles. This ensures a consistent user experience.</p>

<h3>ABAP Text</h3>

<p>ABAP stands for "As Big As Possible". A tiny snippet of jQuery dynamically sizes text to fit in its bounds. Whether you're displaying on a 60" LED TV or a 13" Monitor, the text will be as big and clear as possible.</p>

<h3>Adding Travis</h3>

<p>Brace yourself for a meta-moment. Since I wanted Stoplight to become a popular open-source project, I added the build on Travis CI. With <a href="http://travis-ci.org/#!/customink/stoplight">Stoplight on Travis CI</a> we can use Stoplight to monitor the build status of Stoplight.</p>

<h2>Conclusion</h2>

<p>There you have it! What was once a very isolated and less-than-configurable tool is now highly extensible and open to contributions by the community. If you are currently using Greenscreen or another build monitoring alternative, give Stoplight a try.</p>

<h2>I Want it!</h2>

<p>Stoplight is available for <a href="https://github.com/customink/stoplight">download and forking on github</a>. Pull requests are greatly welcome! There is also a highly-configurable <a href="https://github.com/customink-webops/stoplight">chef cookbook for installing Stoplight</a> on Apache and Passenger on your own servers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVT:  Foodcritic and Travis CI]]></title>
    <link href="http://technology.customink.com/blog/2012/06/04/mvt-foodcritic-and-travis-ci/"/>
    <updated>2012-06-04T13:45:00-04:00</updated>
    <id>http://technology.customink.com/blog/2012/06/04/mvt-foodcritic-and-travis-ci</id>
    <content type="html"><![CDATA[<p>One of the big themes that emerged during <a href="http://chefconf.opscode.com/">#ChefConf</a> was that we should be testing our infrastructure code.  Software engineers have been practicing test-driven development, behavior-driven development, continuous integration, and many other testing-related practices for a long time.  It's becoming more important for the infrastructure engineers to learn from and apply these practices to our day-to-day workflow.  When it comes to testing Chef-driven infrastructure automation, there are a number of tools and practices that are starting to emerge.  In this article I'll look at a "minimum viable testing" (MVT) approach to this problem using <a href="http://acrmp.github.com/foodcritic/">Foodcritic</a> and <a href="http://travis-ci.org/">Travis CI</a>.  <a href="http://technology.customink.com/blog/2012/06/04/mvt-foodcritic-and-travis-ci/#steps">Follow the steps in this article</a> to get your public cookbooks tested after every <code>git push</code>.</p>

<h3>Testing with Chef</h3>

<p>The idea of building automated tests for your infrastructure code has been getting a lot of traction lately.  When it comes to <a href="http://www.opscode.com/chef/">Chef</a>, many tools are starting to emerge.</p>

<p>The first tool in this area to get any significant traction, that I know of, was <a href="http://www.cucumber-chef.org/">cucumber-chef</a>.  I first learned of this tool when I saw a pre-release copy of <a href="http://shop.oreilly.com/product/0636920020042.do">Test-Driven Infrastructure with Chef</a> at the O'Reilly booth at <a href="http://velocityconf.com/velocity2011">Velocity Conf 2011</a>.  <a href="http://twitter.com/lordcope">Stephen Nelson-Smith</a>, the book's author and framework's lead developer, proposes an outside-in approach to testing where your tests can also act as monitors that look after the health of your infrastructure.  I like the idea of this approach and feel it makes a lot of sense in a greenfield environment.  One benefit of this approach is that it blurs the line between testing and monitoring.  You can easily hook-up your monitoring system to your cucumber tests.</p>

<p><a href="https://github.com/acrmp/chefspec">ChefSpec</a> is another tool for testing your Chef code.  It is a gem that makes it easy to write <a href="http://rspec.info/">RSpec</a> examples for Chef cookbooks.  This style of testing allows you to execute your tests without needing to converge the node that your tests are running on.  In other words, you can execute your tests without needing to provision a server.  One huge appeal to this style of testing is that the feedback loop is very small.  You'll get feedback about your cookbook changes within seconds or a very few minutes of saving your changes.</p>

<p><a href="https://github.com/calavera/minitest-chef-handler">Minitest Chef Handler</a> is yet another tool for testing with Chef.  This runs a suite of <a href="https://github.com/seattlerb/minitest">minitest</a> tests as a report handler in your Chef-managed nodes.  As you may know, report handlers are run at the end of each <a href="http://wiki.opscode.com/display/chef/Anatomy+of+a+Chef+Run">chef run, or convergence</a>.</p>

<h3>Testing at ChefConf</h3>

<p>At the inaugural <a href="http://chefconf.opscode.com">#ChefConf</a> there were many sessions that included information about many companies' approach to testing.  Here's a quick list of some of the sessions:</p>

<ul>
<li><p><a href="http://www.foodfightshow.org/2012/04/episode-10-testallthethings-testing.html">Food Fight Show Episode #10 - TESTALLTHETHINGS</a> -- This wasn't actually part of #ChefConf but is 'required listening' for anyone interested in learning more about this space.</p></li>
<li><p><a href="http://chefconf2012.sched.org/event/bfe13edac99e2b4d8582f0cd1005ee73?iframe=no&amp;w=700&amp;sidebar=no&amp;bg=no">#ChefConf Pre-event Hackday: TEST ALL THE THINGS!!!</a></p></li>
<li><p><a href="https://github.com/atomic-penguin/ntp">NTP Cookbook with tests</a> - tests were added to this cookbook as part of the hackday event.</p></li>
<li><p><a href="http://www.youtube.com/watch?v=o2e0aZUAVGw">Test-driven Development for Chef Practitioners</a> (video)</p></li>
<li><p><a href="http://www.youtube.com/watch?v=dPaYfAIvqxw">Test Driven Development Roundtable</a> (video)</p></li>
</ul>


<!--more-->


<h3>Foodcritic</h3>

<p><a href="http://acrmp.github.com/foodcritic/">Foodcritic</a> is a lint tool for your Chef cookbooks.</p>

<p><blockquote><p></p></p><p><p>Foodcritic has two goals:</p></p><p><ul><br/><li><p>To make it easier to flag problems in your Chef cookbooks that will cause Chef to blow up when you attempt to converge. This is about faster feedback. If you automate checks for common problems you can save a lot of time.</p></li><br/><li><p>To encourage discussion within the Chef community on the more subjective stuff - what does a good cookbook look like? Opscode have avoided being overly prescriptive which by and large I think is a good thing. Having a set of rules to base discussion on helps drive out what we as a community think is good style.</p></blockquote></p></li>
</ul>


<h4>Why start with Foodcritic?</h4>

<p>Given the plethora of options available, why should you start with Foodcritic?  Well, you have to start somewhere.  We felt Foodcritic was a good choice because it was easy to get started with, the tests ran quickly, and we are working under the assumption that once we started some automated testing, we'll start layering on more and more pieces as we go.  After some initial experiments, we found that we could get Foodcritic looking after our each cookbook in a matter of minutes and local tests running in seconds.</p>

<p>The pseudo-converge approaches (like ChefSpec) initially feel like we'll need to do a lot of mocking that will take some time to get correct.  The post-converge approaches (like cucumber-chef and minitest) will take longer to run and are a bit more complex.</p>

<p>One benefit of the post-converge approach is the ability to use your tests as health monitors.  We already have monitoring in place and use it as an indicator that a node is fully provisioned.  We call this "monitor-driven development."  Given that, it was better for us to get started with something that runs without requiring a full converge.  Foodcritic fit the bill quite nicely.</p>

<h3>Travis CI</h3>

<p>Travis CI is:</p>

<p><blockquote><p>A hosted continuous integration service for the open source community.</p></blockquote></p>

<p>Using Travis CI in conjunction with Foodcritic, we'd have a basic automated test foundation to build on.</p>

<h3>Automated Foodcritic tests with Travis CI <a name="steps"></a></h3>

<p>Using Foodcritic and Travis CI, you can quickly set-up a "minimum viable testing" (MVT) environment.  The idea is that once you have some sort of tests running against your cookbooks, you'll want to add more and doing so will be easy.  Let's look at how to add Foodcritic and Travis CI to your cookbook workflow.</p>

<h4>Initial set-up</h4>

<p>Follow these steps to get everything set-up and ready for your first tests:</p>

<ol>
<li><code>gem install foodcritic</code></li>
<li>Go to <a href="http://travis-ci.org/">Travis CI</a> and follow the Sign In link at the top.</li>
<li>Activate the GitHub Service Hook for your cookbook's repository from your TravisCI profile page.  Each of your cookbooks has its own repository, right?!</li>
</ol>


<h4>Configure your project</h4>

<p>The next step is to add a .travis.yml file to your project.</p>

<p><code>ruby .travis.yml
language: ruby
gemfile:
   - test/support/Gemfile
rvm:
  - 1.9.2
  - 1.9.3
script: bundle exec rake foodcritic
</code></p>

<p>This file tells Travis CI how to build your project.  We've specified the language (ruby) and the versions of ruby to use when testing this cookbook (1.9.2 and 1.9.3).  We've also specified a Gemfile and script to execute when testing this project.  Let's add a Gemfile to a new directory in our cookbook, <code>test/support</code>.</p>

<p><code>sh
mkdir -p test/support
touch test/support/Gemfile
</code></p>

<p>Our Gemfile is pretty simple, just include <code>rake</code> and <code>foodcritic</code>.</p>

<p>``` ruby Gemfile
source "https://rubygems.org"</p>

<p>gem 'rake'
gem 'foodcritic'
```</p>

<p>Finally, we'll need to add a Rake file that will be run each time Travis builds our project.</p>

<p>``` ruby Rakefile</p>

<h1>!/usr/bin/env rake</h1>

<p>desc "Runs foodcritic linter"
task :foodcritic do
  if Gem::Version.new("1.9.2") &lt;= Gem::Version.new(RUBY_VERSION.dup)</p>

<pre><code>sandbox = File.join(File.dirname(__FILE__), %w{tmp foodcritic cookbook})
prepare_foodcritic_sandbox(sandbox)

sh "foodcritic --epic-fail any #{File.dirname(sandbox)}"
</code></pre>

<p>  else</p>

<pre><code>puts "WARN: foodcritic run is skipped as Ruby #{RUBY_VERSION} is &lt; 1.9.2."
</code></pre>

<p>  end
end</p>

<p>task :default => 'foodcritic'</p>

<p>private</p>

<p>def prepare_foodcritic_sandbox(sandbox)
  files = %w{<em>.md </em>.rb attributes definitions files providers
recipes resources templates}</p>

<p>  rm_rf sandbox
  mkdir_p sandbox
  cp_r Dir.glob("{#{files.join(',')}}"), sandbox
  puts "\n\n"
end</p>

<p>```</p>

<p>This Rakefile will copy the contents of our cookbook to a temporary directory and run the foodcritic tests on the temporary directory.  Note the <code>--epic-fail</code> tag is used to fail the build (return a non-zero exit code) on <code>any</code> rule that does not pass.</p>

<p>That's it!  When you push your commit to github, you should see Travis CI pick-up the changes, run your build, and report on status.</p>

<h3>Share Your Build Status</h3>

<p>One final step that you may consider is adding a build status indicator to your README.  This simple line in your README will let others know what the current build status is for your cookbook.</p>

<p>``` sh</p>

<p><a href="http://travis-ci.org/[YOUR_GITHUB_USERNAME]/[YOUR_PROJECT_NAME]"><img src="https://secure.travis-ci.org/[YOUR_GITHUB_USERNAME]/[YOUR_PROJECT_NAME].png" alt="Build Status" /></a></p>

<p>```</p>

<h3>Thanks &amp; Additional Resources</h3>

<p>A big "Thank You!" shout-out to <a href="https://twitter.com/fnichol">Fletcher Nichol</a> and <a href="https://twitter.com/atomic_penguin">Eric G. Wolfe</a> from whom I 'borrowed' the <code>Rakefile</code> and <code>.travis.yml</code> used in this post.</p>

<p>More information on Foodcritic and Travis CI can be found here:</p>

<ul>
<li><a href="http://acrmp.github.com/foodcritic/">Foodcritic</a></li>
<li><a href="http://about.travis-ci.org/docs/user/getting-started/">Travis CI: Getting started guide</a></li>
<li><a href="http://about.travis-ci.org/docs/user/status-images/">Travis CI: Status Images</a></li>
</ul>


<hr />

<p><sub>Reposted from <a href="http://nathenharvey.com/blog/2012/05/29/mvt-foodcritic-and-travis-ci/">Nathen Harvey's blog</a><sub></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Provision your laptop with Chef: Part 1]]></title>
    <link href="http://technology.customink.com/blog/2012/05/28/provision-your-laptop-with-chef-part-1/"/>
    <updated>2012-05-28T20:32:00-04:00</updated>
    <id>http://technology.customink.com/blog/2012/05/28/provision-your-laptop-with-chef-part-1</id>
    <content type="html"><![CDATA[<p>If you have ever tried to follow the <a href="http://wiki.opscode.com/display/chef/Getting+Started">Opscode Getting Started Guide for Chef</a>, you'll quickly be overtaken by Chef jargon, confusing instructions, many assumptions, and no clear direction. Even the most experienced developers had a difficult time following the Opscode Wiki. While it serves as a great reference resource, you pretty much have to know Chef before it is of any use.</p>

<p>In Part 1 of this 2-part series, we will walk through setting up the Chef environment on your local machine. In Part 2, we will demonstrate how to provision your personal laptop using Chef.</p>

<!-- more -->


<h2>What is Chef?</h2>

<p>One of the best things about Chef is that it is idempotent. Unlike a simple bash script or complex startup script, Chef can be applied to the same machine hundreds of times. Only the "changes" will be executed on each of the clients. This makes deploying and updating thousands of machines as easy as baking a cake!</p>

<h2>Understanding Chef &amp; Jargon</h2>

<p>One of the most interesting and confusing parts about Chef is its lingo. Everything relates to <strong>food</strong>. Be sure to grab a snack before diving in any further.</p>

<h3>Architecture</h3>

<p>One of the most dangerous practices when using Chef is applying prior knowledge. In Chef, everything is named relative to Chef. This means, even though your are provisioning a production <em>server</em>, it's still a Chef <em>client</em>. This can be very confusing at first, but once you start thinking in terms of Chef things will begin to make sense.</p>

<ul>
<li><code>(Chef) Server</code> [aka hosted chef] - refers a machines that stores cookbooks, roles, and other Chef configurations</li>
<li><code>(Chef) Client</code> [aka node] - refers to a machine that connects to and is managed by a Chef Server</li>
<li><code>(Chef) Workstation</code> - refers to a machine where recipes are developed, altered, deleted, and more</li>
</ul>


<p>This is the most simplistic picture. It's possible for a single machine to exist in all three of these roles simultaneously! There are subsets of Chef, such as <a href="http://wiki.opscode.com/display/chef/Chef+Solo">Chef-Solo</a>, but those will not be discussed here.</p>

<p>A typical scenario begins at the workstation. A developer creates a cookbook, role, or other artifact on the local machine. When finished, that artifact is uploaded to the Chef Server. The Chef Clients receive these (new) instructions and execute them locally.</p>

<p><img src="/images/chef-architecture.png" alt="Chef Architecture Graph" /></p>

<h3>Jargon</h3>

<p>We've also been throwing around some other terms that we should take a second to define:</p>

<ul>
<li><code>cookbook</code> - collection of recipe, resources, attributes, templates, metadata, and other files</li>
<li><code>recipe</code> - a set of instructions written in a Ruby DSL that tells a node what commands to execute</li>
<li><code>metadata</code> - additional information, such as dependencies, for a given cookbook</li>
<li><code>resource</code> - cross-platform abstraction of the "thing" you're configuring such as a package or a user</li>
<li><code>provider</code> - a platform-specific implementation of a resource</li>
<li><code>data bag</code> - JSON key-value store for storing data, attributes, and more</li>
<li><code>environment</code> - provide a mechanism for managing different deployment locations such as production, staging, development, and testing</li>
<li><code>template</code> - a file (like a config file) to be "rendered" on the server</li>
</ul>


<p> There are also a few tools:</p>

<ul>
<li><code>knife</code> - a command line tool for managing chef and chef recipes</li>
<li><code>shef</code> - chef console. this is the equivalent of <code>rails console</code> for chef</li>
</ul>


<p>Before continuing, please make sure you understand that these are very over-simplified definitions and abstractions. Chef is much more powerful that these simplistic definitions allow.</p>

<h2>Set up your Opscode Account</h2>

<p>For the purposes of this tutorial, we will use Chef Hosted by Opscode (the creators of Chef). The service provides 5 free nodes for use. Go ahead and create your free account by heading over to the <a href="https://community.opscode.com/users/new">Hosted Chef Signup page</a>. You should see something like this:</p>

<p><img src="/images/hosted-chef-signup.png" alt="Hosted Chef Signup page" /></p>

<p>You'll need to confirm your email, but once that's done, head on over to the <a href="https://manage.opscode.com/organizations">Opscode Management Console</a>. It really doesn't matter what you call your organization - I used the same as my username. You should see a screen like this:</p>

<p><img src="/images/hosted-chef-management-console.png" alt="Hosted Chef Management Console" /></p>

<p>You probably only have one organization, but the image should give you a good idea. First thing you'll want to do is <strong>Regenerate validation key</strong> and <strong>Generate knife config</strong>. We will talk about this more in detail, but save these files in a handy place for later. These files should always be kept securely.</p>

<p>Also, if you didn't get your private key when registering, you should do that now (for some reason, Opscode does not always stream the key). Go to the <a href="http://community.opscode.com/">Opscode Community Site</a> and login (if you aren't already). Click on your profile and then choose <strong>get private key</strong>.</p>

<p><img src="/images/chef-community-user.png" alt="Chef Community User" /></p>

<p>At this point you should have the following files:</p>

<pre><code>[your_organization_name]-validator.pem
[your_username].pem
knife.rb
</code></pre>

<p>For example, mine would be:</p>

<pre><code>ci-validator.pem
sethvargo.pem
knife.rb
</code></pre>

<p>Sometimes Opscode doesn't stream the correct files, so you may need to do some renaming:</p>

<pre><code>_knife_config   #=&gt; knife.rb
_regenerate_key #=&gt; [your_organization_name]-validator.pem
</code></pre>

<h2>Install Ruby, Chef, and Git</h2>

<p>Chef is written in Ruby. Therefore, you must have Ruby installed. Installing Ruby is beyond the scope of this topic, but here are some quick resources:</p>

<ul>
<li><a href="http://rubyinstaller.org/">Ruby Installer for Windows</a> (also install the <a href="https://github.com/oneclick/rubyinstaller/wiki/development-kit">Development Kit</a>)</li>
<li><a href="http://rvm.io/">Installing Ruby with rvm</a></li>
<li><a href="https://github.com/sstephenson/rbenv">Installing Ruby with rbenv</a></li>
</ul>


<p>You should also install <code>git</code>. Check out the <a href="http://help.github.com/set-up-git-redirect">Github tutorial for installing git</a>.</p>

<p>Once you have Ruby and Git installed, you'll need to install chef:</p>

<pre><code>gem install chef
</code></pre>

<p>This command will install the Chef gem as well as some other dependencies.</p>

<p>A this point, you should have a novice understand of Chef and Chef Jargon, have an account on Opscode Hosted Chef, and have a working version of Ruby, Git, and the Chef gem installed. The rest of this guide will assume you have completed all those steps correctly.</p>

<h2>Setup your Workstation</h2>

<p>Find a working directory on your local machine where you plan to store your Chef cookbooks. For this tutorial, we will use <code>~/Development</code>. You'll need a skeleton chef repository. You could make your own or clone the Opscode one:</p>

<pre><code>git clone git@github.com:opscode/chef-repo.git
</code></pre>

<p>Take a few minutes to poke around the repository. You definitely won't understand everything, but look at a few READMEs (in subdirectories).</p>

<p>Inside the <code>chef-repo</code> directory (<code>~/Development/chef-repo</code>), we need to create a hidden folder named <code>.chef</code>:</p>

<pre><code>cd ~/Development/chef-repo
mkdir .chef
</code></pre>

<p>This is where you should put the files we downloaded earlier:</p>

<pre><code>mv [location]/[your_username].pem ~/Development/chef-repo/.chef/
mv [location]/[your_organization_name].pem ~/Development/chef-repo/.chef/
mv [location]/knife.rb ~/Development/chef-repo/.chef/
</code></pre>

<p>For my case, it would be:</p>

<pre><code>mv ~/Desktop/sethvargo.pem ~/Development/chef-repo/.chef/
mv ~/Desktop/ci-validator.pem ~/Development/chef-repo/.chef/
mv ~/Desktop/knife.rp ~/Development/chef-repo/.chef/
</code></pre>

<p>To confirm everything is working, try and list all the clients (it should be empty):</p>

<pre><code>knife client list
</code></pre>

<p>If this command succeeds without error, everything is set up correctly!</p>

<p>This concludes setting up your workstation. Now we are ready to create our first cookbook.</p>

<h2>Create your first cookbook</h2>

<p>Wash your hands, put on your Chef's Hat, and get ready to bake! We are going to create your very first cookbook. The cookbook will be very simple and is more for demonstrating working with <code>knife</code> and <code>chef-client</code>.</p>

<p>Our cookbook will be named "hello world". Let's start by using <code>knife</code> to create our cookbook skeleton:</p>

<pre><code>cd ~/Development/chef-repo
knife cookbook create hello_world
</code></pre>

<p>You should see the following output:</p>

<pre><code>** Creating cookbook hello_world
** Creating README for cookbook: hello_world
** Creating metadata for cookbook: hello_world
</code></pre>

<p>Open up the project in your favorite text editor and look inside the <code>cookbooks</code> directory. You should see the following:</p>

<p><img src="/images/chef-cookbook-structure.png" alt="Chef Cookbook Structure" /></p>

<p>This cookbook will create a file <code>~/hello_world.txt</code> that says "Hello World!".</p>

<p>Let's first make the template. A template is like the "view" of MVC. It has access to instance variables and uses embedded ruby. Inside the <code>templates/default</code> directory, create a new file named <code>hello-world.txt.erb</code> and add some content:</p>

<p>```erb
&lt;% # templates/default/hello-world.txt.erb %>
Hello World!</p>

<p>Chef Version: &lt;%= node[:chef_packages][:chef][:version] %>
Platform: &lt;%= node[:platform] %>
Version: &lt;%= node[:platform_version] %>
```</p>

<p>You can see we are referencing a <code>node</code> variable. This refers to the current client that Chef is running on.</p>

<p>Now we need to create the actual recipe with instructions. You can think of the recipe as the "controller" of MVC. Open up the <code>recipes/default.rb</code> file and add the following:</p>

<p>```ruby</p>

<h1>recipes/default.rb</h1>

<p>template "#{ENV['HOME']}/hello-world.txt" do
  source 'hello-world.txt.erb'
  mode '0644'
end
```</p>

<p>The <code>template</code> keyword is a resource like we defined before. It tells the recipe to render the given template source to the given file. We also specify the file permissions using <code>mode</code>.</p>

<p>That's it! Our cookbook is done and ready to be uploaded to Hosted Chef. We will use the <code>knife</code> command to do this:</p>

<pre><code>knife cookbook upload hello_world
</code></pre>

<p>You should see output like this:</p>

<pre><code>Uploading hello_world             [0.0.1]
Uploaded 1 cookbook.
</code></pre>

<p>If you get a message like:</p>

<pre><code>WARNING: No knife configuration file found
ERROR: Your private key could not be loaded from /etc/chef/client.pem
Check your configuration file and ensure that your private key is readable
</code></pre>

<p>it means that your key is invalid. Regenerate your personal and/or organization keys and ensure everything is placed in the correct directories.</p>

<p>Our cookbook is now on Hosted Chef and ready to be distributed to our nodes. Chef doesn't automatically tell nodes to update. You can do this with a cron job, running <code>chef-client</code> as a service, or by running <code>chef-client</code> manually on any node.</p>

<p>For simplicity, let's just run this on our local workstation. Let's set up the local workstation as a client. Run the following command from the inside the repository:</p>

<pre><code>sudo knife configure client /etc/chef
</code></pre>

<p>If you're using <code>rvm</code>, use the <code>rvmsudo</code> command prefix:</p>

<pre><code>rvmsudo knife configure client /etc/chef
</code></pre>

<p>You should see output like:</p>

<pre><code>Creating client configuration
Writing client.rb
Writing validation.pem
</code></pre>

<p>That's it! Your workstation is now a client. Let's provision this server by running <code>chef-client</code>:</p>

<pre><code>sudo chef-client
</code></pre>

<p>Or with RVM:</p>

<pre><code>rvmsudo chef-client
</code></pre>

<p>You should see output like this:</p>

<pre><code>INFO: *** Chef 0.10.10 ***
INFO: Client key /etc/chef/client.pem is not present - registering
INFO: Run List is []
INFO: Run List expands to []
INFO: Starting Chef Run for NODE
INFO: Running start handlers
INFO: Start handlers complete.
INFO: Loading cookbooks []
WARN: Node NODE has an empty run list.
INFO: Chef Run complete in 0.988165 seconds
INFO: Running report handlers
INFO: Report handlers complete
</code></pre>

<p>Take a look inside your <code>$HOME</code> directory and see if the <code>hello-word.txt</code> file was created...</p>

<p>It doesn't appear the file was created. We must have done something wrong! Actually, we did everything correctly. We just forgot one step - we never <strong>told</strong> our node to execute the recipe we just wrote. By default, Chef does not execute any of your recipes. You must explicitly require them. There are a variety of ways to do this. We will use a <code>run_list</code> here.</p>

<p>First, we need to figure out what our node is named. Run <code>knife node list</code> and you should now see two nodes:</p>

<pre><code>NODE
[your_organization_name]-validator
</code></pre>

<p>Mine looks like:</p>

<pre><code>seth
sethvargo-validator
</code></pre>

<p>We obviously want <code>NODE</code>. In my case, it's <code>seth</code>. Now we can edit the <code>run_list</code> for that node:</p>

<pre><code>knife node run_list add NODE hello_world
</code></pre>

<p>For me, that command would look like:</p>

<pre><code>knife node run_list add seth hello_world
</code></pre>

<p>You should see the following output:</p>

<pre><code>run_list:  [recipe[hello_world]]
</code></pre>

<p>Let's inspect this node using the <code>show</code> command:</p>

<pre><code>knife node show NODE
</code></pre>

<p>You should now see <code>hello_world</code> in the <code>run_list</code>. Run the <code>chef-client</code> command again (remember you might need to use <code>sudo</code>) and you should get output like the following:</p>

<pre><code>INFO: *** Chef 0.10.10 ***
INFO: Run List is [recipe[hello_world]]
INFO: Run List expands to [hello_world]
INFO: Starting Chef Run for seth
INFO: Running start handlers
INFO: Start handlers complete.
INFO: Loading cookbooks [hello_world]
INFO: Storing updated cookbooks/hello_world/recipes/default.rb in the cache.
INFO: Processing template[/Users/seth/hello-world.txt] action create (hello_world::default line 10)
INFO: template[/Users/seth/hello-world.txt] mode changed to 644
INFO: template[/Users/seth/hello-world.txt] updated content
INFO: Chef Run complete in 1.188536 seconds
INFO: Running report handlers
INFO: Report handlers complete
</code></pre>

<p>Open up your <code>$HOME</code> directory and you should see a file named <code>hello-world.txt</code>. Look inside and you'll see the those node variables were translated into plain text. Awesome!</p>

<p>You can delete that file or leave it around as a reminder of how awesome Chef is. We have one last thing to do before we are done with this tutorial.</p>

<p>Let's remove that recipe from the <code>run_list</code>:</p>

<pre><code>knife node run_list remove NODE hello_world
</code></pre>

<p>Again, mine would be:</p>

<pre><code>knife node run_list remove seth hello_world
</code></pre>

<p>You should see output like the following:</p>

<pre><code>run_list:  [recipe[hello_world]]
</code></pre>

<p>Well, this concludes this (rather lengthy) tutorial on installing Chef, registering for Hosted Chef, creating your first cookbook, and provisioning your first machine.</p>

<p>Part 2 of this series will cover more recipes and full provisioning and customization of your personal laptop using Chef.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 Things You Always Wanted to Know About Chef]]></title>
    <link href="http://technology.customink.com/blog/2012/05/26/5-things-you-always-wanted-to-know-about-chef/"/>
    <updated>2012-05-26T21:51:00-04:00</updated>
    <id>http://technology.customink.com/blog/2012/05/26/5-things-you-always-wanted-to-know-about-chef</id>
    <content type="html"><![CDATA[<p>When I first started working with Chef, there were a couple of areas that I knew were going to be really awesome and helpful but I wasn't sure how to get started with them.  In this presentation, I'll provide a quick introduction to five things you've always wanted to know about Chef but were afraid to ask.</p>

<p>I gave this presentation at <a href="http://chefconf.opscode.com">#ChefConf 2012</a>.</p>

<p>Level-up your Chef skills by learning about these areas of Chef:</p>

<ul>
<li><strong>Attribute Precedence</strong> - Role, environment, cookbook, data bag? Which attribute value will be used in my chef run?</li>
<li><strong>Encrypted Databags</strong> - Chef 0.10 brought us encrypted databags. We'll look at how to create and use databags and how to keep them up-to-date in your repository.</li>
<li><strong>LWRP</strong> - What is a LWRP? How and why do you create one? We'll look at a couple of sample LWRPs and learn how to build a simple one.</li>
<li><strong>Error Handlers</strong> - Demystify exception and report handlers by writing a simple one and seeing examples of how they work in the wild.</li>
<li><strong>Capistrano and Chef</strong> - Take a quick look at why and how to integrate Chef search into your Capistrano configuration to make deploying your Rails apps even easier.</li>
</ul>


<p>One thing I didn't mention in the presentation was how to use the data from the encrypted data bag.  I've updated the slides to include this info but it doesn't appear in the video.  In any case, here's a quick demo of how you might use it:</p>

<p>``` ruby
creds = Chef::EncryptedDataBagItem.load("db", "creds")
env_db_creds = db_creds[node["rails_env"]]</p>

<p>template "#{app_dir}/shared/config/database.yml" do
  source "database.yml.erb"
  variables(</p>

<pre><code>:rails_env =&gt; node["rails_env"],
:username =&gt; env_db_creds["username"],
:password =&gt; env_db_creds["password"]
</code></pre>

<p>  )
end
```</p>

<h3>Video</h3>

<iframe width="560" height="315" src="http://www.youtube.com/embed/uREL4FFPddo" frameborder="0" allowfullscreen></iframe>


<h3>Slides</h3>

<script async class="speakerdeck-embed" data-id="4fb532f2850667001f0008f8" data-ratio="1.2945638432364097" src="http://technology.customink.com//speakerdeck.com/assets/embed.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Joy of Cooking - Whip Up a Rails Environment with Chef]]></title>
    <link href="http://technology.customink.com/blog/2012/05/25/the-joy-of-cooking-whip-up-a-rails-environment-with-chef/"/>
    <updated>2012-05-25T14:59:00-04:00</updated>
    <id>http://technology.customink.com/blog/2012/05/25/the-joy-of-cooking-whip-up-a-rails-environment-with-chef</id>
    <content type="html"><![CDATA[<p>You've heard of Chef, Puppet, and other frameworks that can help you build out your infrastructure. You've been meaning to play around with one or more of them for some time now. Now's your chance; Start cooking up on your own servers!</p>

<p>In this presentation, I provide an introduction to Chef with a focus on what you'll need to know to get a Rails application up and running.</p>

<p>Topics include:
  * Introduction to Chef
  * Nodes, roles, environments, and other terminology
  * Introduction to cookbooks
  * Provisioning an environment for a Rails application
  * Deploying with Capistrano</p>

<p>You won't be ready to compete in Iron Chef, but you will be ready to serve up your own Rails environment in no time.</p>

<p>I gave slightly different versions of this presentation at <a href="http://www.rubynation.org/">RubyNation 2012</a> and <a href="http://chefconf.opscode.com">#ChefConf 2012</a>.</p>

<p>I'd really appreciate any comments, questions, or feedback in the comments section below.</p>

<h3>Video from ChefConf</h3>

<iframe width="560" height="315" src="http://www.youtube.com/embed/X1mmzERRkeI" frameborder="0" allowfullscreen></iframe>


<h3>Slides</h3>

<script async class="speakerdeck-embed" data-id="4fb421272cf6f5001f00ba85" data-ratio="1.2945638432364097" src="http://technology.customink.com//speakerdeck.com/assets/embed.js"></script>

]]></content>
  </entry>
  
</feed>
