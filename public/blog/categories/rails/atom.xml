<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | EngineerInk]]></title>
  <link href="http://technology.customink.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://technology.customink.com/"/>
  <updated>2012-05-17T16:37:43-04:00</updated>
  <id>http://technology.customink.com/</id>
  <author>
    <name><![CDATA[CustomInk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Critical Oversight: Indexes]]></title>
    <link href="http://technology.customink.com/blog/2012/04/27/critical-oversight-indexes/"/>
    <updated>2012-04-27T11:48:00-04:00</updated>
    <id>http://technology.customink.com/blog/2012/04/27/critical-oversight-indexes</id>
    <content type="html"><![CDATA[<p>One of the most common production issues I run into are missing indexes.  The other day I got to thinking that they are usually missing because of the evolution of the software.</p>

<p>We might use some rails generators to prototype some basic functionality.  Then we'll iterate over a set of stories incorporating new behavior.  Maybe we'll do some refactoring, scrap some features, pull out some dead code and "harden" some areas we've identified as brittle.  But we almost never analyze the "data model" before we deploy.</p>

<p>Have we considered our data access patterns?  Did we create foreign keys to enforce data integrity?  Do we have any idea how big these tables are going to grow?  We almost certainly don't need to shard themâ€¦do we?</p>

<p>No, we almost never do this.</p>

<p>Instead we race to ship.  "<a href="http://www.customink.com/lab/?cid=jub0-000p-fxs7#shared">Deploy early, deploy often</a>" is our motto, and we love it.  Deploying code is awesome, it means people are going to use it.  People using our code makes us happy because it means we didn't waste our time today.  We did something real that people got to use.</p>

<p>A few months down the road comes the tipping point.  One of your tables amasses a few hundred thousand rows.  Your pages start to take seconds to load because your queries take seconds to run.  Your database connections are tied up, and when your site gets enough traffic, things start to fall over.</p>

<p>This literally just happened to us.  Again.  We missed one little index on one little foreign key in one little table.  And then one of our database servers stopped responding.   Spiked CPU, connections maxed out, alerts firing, then fail over.</p>

<p>While Rails makes it really easy to create models without even thinking about the database, Rails also makes it very easy to deal with the database.  In James Edward Gray's talk <a href="http://speakerdeck.com/u/jeg2/p/10-things-you-didnt-know-rails-could-do?utm_source=rubyweekly&amp;utm_medium=email">10 Things You Didn't Know Rails Could Do</a> he shows you how to use rails migration generators to create your table AND index your fields.</p>

<p>If you don't like generators, you can simply use the 'add_index' method in the migration itself:</p>

<p>```ruby
class CreateFoo &lt; ActiveRecord::Migration
  self.up</p>

<pre><code>create_table :foos do |t|
  t.integer :foreign_key
  t.string  :other_valuable_data
end

add_index(:foos, :foreign_key, :name =&gt; 'foos_foreign_key')
</code></pre>

<p>  end
end
```
Of course, if you don't think to add the index when you created the table, you can always create a migration just to add the index.  The key is adding a checkpoint to your development process in which you analyze your data structures for completeness.  Adding this checkpoint gives you a chance to add any missing database constructs before it's too late.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Data Mapper]]></title>
    <link href="http://technology.customink.com/blog/2012/03/02/simple-data-mapper/"/>
    <updated>2012-03-02T15:35:00-05:00</updated>
    <id>http://technology.customink.com/blog/2012/03/02/simple-data-mapper</id>
    <content type="html"><![CDATA[<p>I recently tackled a pretty typical data migration task where some source model had to be transformed into some target model.  About 80% of the elements were mapped field for field, and the other 20% had to be mutated in some way.  Tired of writing one off rake tasks to pull and transform data, I came up with a little data mapper class that I cold reuse in the future.</p>

<p>```ruby
class Mapper
  attr_accessor :source_model
  attr_accessor :mappings</p>

<p>  class AttributeMapping;end</p>

<p>  class ListMapping &lt; AttributeMapping</p>

<pre><code>attr_accessor :fields

# fields - array of field symbols we want to map data into
def initialize(fields)
  self.fields = fields
end

def transform(source_obj, source_attribute)
  {}.tap do |values|
    fields.each do |field|
      values[field] = source_obj.send(source_attribute)
    end
  end
end
</code></pre>

<p>  end</p>

<p>  class ComplexMapping &lt; AttributeMapping</p>

<pre><code>attr_accessor :field
attr_accessor :instruction

# field       - field symbol we want to map data into
# instruction - lambda which accepts source object and source attribute. 
#               expected to return value to be mapped to field (on target obj)
def initialize(field, instruction)
  self.field = field
  self.instruction = instruction
end

def transform(source_obj, source_attribute)
  { field =&gt; instruction.call(source_obj, source_attribute) }
end
</code></pre>

<p>  end</p>

<p>  def initialize(source_model, mappings)</p>

<pre><code>self.source_model = source_model
self.mappings = mappings
</code></pre>

<p>  end</p>

<p>  def conjure(model)</p>

<pre><code>values = map_values_for( self.source_model, self.mappings )
model.to_s.camelize.constantize.new(values)
</code></pre>

<p>  end</p>

<p>  def map_values_for(source_model, mappings)</p>

<pre><code>{}.tap do |values|
  mappings.each do |attr, mapping|
    if AttributeMapping === mapping
      values.update(mapping.transform(source_model, attr))
    else
      values[mapping] = source_model.send(attr)
    end
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Using the mapper is really simple.  Let's say my source model, LegacyCustomer, is based off of a legacy table from an older system and looks like:</p>

<p>```ruby
LegacyCustomer(
  userid: integer,        # primary key
  creationdate: datetime, # date record was created
  accountnum: string      # customer number. it's prefixed with</p>

<pre><code>                      # "LGCY-" string that we no longer need!
</code></pre>

<p>)
```</p>

<p>And we want to migrate the LegacyCustomer data to a new Customer model that looks like:
<code>ruby
Customer(
  id: integer,
  created_at: datetime,
  updated_at: datetime,
  account_number: string
)
</code></p>

<p>My rake task to run the migration would look like:
```ruby
namespace :migrate do
  task :legacy_customers do</p>

<pre><code>field_mappings = {
  :userid         =&gt; :id,
  :creation_date  =&gt; Mapper::ListMapping.new(
                      [:created_at, :update_at]
                     ),
  :user_data      =&gt; Mapper::ComplexMapping.new(
                      :account_number, 
                      lambda {|obj, attr| obj.send(attr).gsub('LGCY-','')}
                     )
}

LegacyCustomer.all.each do |legacy_customer|
  mapper = Mapper.new(legacy_customer, field_mappings)
  customer = mapper.conjure(:customer)
  customer.save!
end
</code></pre>

<p>  end
end
```</p>

<p>As my migration marched on 'one off' data errors would pop up causing the script to fail.  This is what ultimately led me to create the ComplexMapping class.  Every time some white space, funny character, or field split requirement bombed my script I was able to add some code to my ComplexMapping requirement to solve it.</p>

<p>I wanted to share this experience for two reasons:</p>

<p>Ruby is awesome.  Metaprogramming and Procs made this mapper possible.  When I first started programming with Ruby, these were the two hardest concepts for me to wrap my head around.  Investing time into learning these aspects of ruby have made me such a better ruby programmer.</p>

<p>The second reason is to reinforce the lesson that doing things the lazy (comfortable) way will rarely ever benefit you.  This mapper class not only made writing and maintaining my migration script easier.  It has also found it's way into some production code.</p>

<p>Abstracting concepts (or remembering the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>) will always benefit you in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Organizing Your Rails Models]]></title>
    <link href="http://technology.customink.com/blog/2012/02/03/organizing-your-rails-models/"/>
    <updated>2012-02-03T15:38:00-05:00</updated>
    <id>http://technology.customink.com/blog/2012/02/03/organizing-your-rails-models</id>
    <content type="html"><![CDATA[<p>Like people, applications start out small.  Unlike people, applications do not always have a predictable growth pattern.  Sometimes they grow really big, and sometimes not at all.  When applications grow large, organization becomes important because it is no longer possible to remember every detail about your application without consulting the source code.</p>

<p>"We use Rails, the convention tells us how to organize our code".  Yes, but having 50 or more files in your app/models directory is hardly being organized.</p>

<p>A simple thing I like to do is group related models into folders.  This allows you to organize the related models of a domain into a single location while any shared or stand alone models simply remain in the root directory.  For instance, my directory structure may look something like:</p>

<p>```
app
|<em>models
   |</em>address.rb
   |_orders</p>

<pre><code>  |_order.rb
  |_item.rb
  |_shipping_detail.rb
</code></pre>

<p>```</p>

<p>And to make sure Rails can find all of my models, I need to update config/application.rb file as such:</p>

<p><code>ruby
config.autoload_paths += ['app/models/**"]
</code></p>

<p>This allows developers to quickly see what models make up an order and what models either stand on their own, or are shared across multiple domains.  And for a large application, you are now able to quickly summarize the high level business objects that make up your system.</p>
]]></content>
  </entry>
  
</feed>
