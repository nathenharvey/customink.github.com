<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | EngineerInk]]></title>
  <link href="http://technology.customink.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://technology.customink.com/"/>
  <updated>2012-04-27T14:57:50-04:00</updated>
  <id>http://technology.customink.com/</id>
  <author>
    <name><![CDATA[CustomInk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RubyNation 2012]]></title>
    <link href="http://technology.customink.com/blog/2012/03/26/rubynation-2012/"/>
    <updated>2012-03-26T13:36:00-04:00</updated>
    <id>http://technology.customink.com/blog/2012/03/26/rubynation-2012</id>
    <content type="html"><![CDATA[<p><a href="http://www.rubynation.org/">RubyNation</a> is awesome.  Most ruby events are awesome, but in particular I enjoy RubyNation because it's local to me.  It's not that I don't like traveling to other conferences or that I think Washington DC is the best possible place for a conference.  What I love about RubyNation being local is having 200+ ruby developers from my immediate locale in one single place, at one single time.  Of course, it doesn't hurt to have <a href="http://onestepback.org">Jim Weirich</a> and <a href="http://coreyhaines.com/">Corey Haines</a> show up, either.</p>

<p>The other thing I love about RubyNation are all the great talks.  Even the bad talks are still good talks.  Even the terrible talks turn into great talks because when you step into the hallway, there are amazing people who showed up to RubyNation waiting to have a great talk with you.  Every year, without fail, I meet new people and learn new things.  I don't think you can put a price tag on that.</p>

<p>There were lots of highlights for me this year, and some surprises.  The first surprise should really have been no surprise at all, since it's a developing trend at all Ruby/Rails related events: JavaScript.  In his opening keynote, Justin Getland says something to the effect of "Adapt or die".  Justin's message was clear: wherever there is a gap, someone will be there to fill it.  There is a gap in JavaScript knowledge, so it's time to step in or someone else will.</p>

<p>The first day at RubyNation had one track that was entirely JavaScript and View focused.  The second track was a grab bag of ruby related topics such as toolkits or programming approaches.  Some of the JS/View track presentations that stuck out to me were:</p>

<p>Roy Tomeij's talk on <a href="http://roytomeij.com/slides/rubynation2012">Modular and Reusable Front-End code</a>,
Brennan Dunn's talk on <a href="http://speakerdeck.com/u/brennandunn/p/rails-without-views">Rails Without Views</a>,
John Athayde's talk on <a href="http://speakerdeck.com/u/boboroshi/p/the-rails-view-the-junk-drawer-grows-up">The Rails View: The Junk Drawer Grows Up</a>,
Chris Strom's talk on <a href="http://speakerdeck.com/u/chris/p/you-aint-spdy-ruby-nation">You Ain't SPDY</a></p>

<p>Andrew Glover's <a href="https://github.com/aglover/resque-example">Asynchronous Processing and Messaging</a> talk was a great introduction to Resque and Redis.  Although I didn't attend his talk, people told me that Mike Subelsky's talk <a href="http://www.subelsky.com/2012/03/slides-from-my-coding-for-uncertainty.html">Coding for Uncertainty</a> was amazing.  Before you knew it, Jim Weirich was wrapping up day one by teaching us how to use Ruby for purely functional programming purposes to implement the <a href="https://twitter.com/#!/karledurante/status/183312951598514176/photo/1">Y Combinator</a>.</p>

<p>Day two had a couple of front end related talks, but really seemed to focus more on some of the toolkits we use with ruby and some theory to help rubyists navigate the programming waters.</p>

<p>I really enjoyed Russ Olsen's <a href="http://speakerdeck.com/u/russolsen/p/eloquent-explanations-rubynation-2012">Eloquent Expressions</a> and Jeff Casimir's <a href="http://speakerdeck.com/u/j3/p/adventures-on-the-golden-path">Adventures on the Golden Path</a>.  As well, Patrick Peak and Nathen Harvey gave great talks on how to better organize your applications with <a href="http://speakerdeck.com/u/peakpg/p/plays-well-with-others-building-mountable-apps">mountable applications</a> and <a href="https://github.com/nathenharvey/cooking-with-chef">deployment strategies</a>, respectively.  <a href="https://github.com/ajburton">Anthony Burton</a> has posted a more <a href="https://gist.github.com/2182892">complete list of talks here</a>.</p>

<p>Corey Haines closed out the event with a call to arms for our community to mentor the next generation.  Corey's point was simple: there is a need for more developers.  Companies will step in to "make" new ones.  Do you want good developers or bad developers?  <a href="http://rubytutor.org/">Ruby Tutor</a> is a place where we can help to make the next generation great.</p>

<p>Thanks to all the people who made RubyNation such a great event this year.  See you all next year.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Garbage Collection Tuning for Rails]]></title>
    <link href="http://technology.customink.com/blog/2012/03/16/simple-garbage-collection-tuning-for-rails/"/>
    <updated>2012-03-16T08:07:00-04:00</updated>
    <id>http://technology.customink.com/blog/2012/03/16/simple-garbage-collection-tuning-for-rails</id>
    <content type="html"><![CDATA[<p>Ruby is known for being bad at garbage collection.  The truth is that the default GC settings aren't very good for a Rails application so if you run a Rails app you really should do some tuning (this requires either Ruby Enterprise or Ruby 1.9.2).  Here's a streamlined process for getting started:</p>

<h3>Get a Baseline</h3>

<p>Turn on collecting GC stats for New Relic (of course you're using <a href="http://newrelic.com/">New Relic</a>).  You want to know what you're fixing and this will probably show you that about &#8531; of the "Ruby" portion of your app response time is really garbage collection.  Just add the following line to your <code>environment.rb</code> file:</p>

<p><code>GC.enable_stats if defined?(GC) &amp;&amp; GC.respond_to?(:enable_stats)</code></p>

<h3>Examine the Heap</h3>

<p>Once you've gathered enough data in NewRelic to be able to see a change, you'll want to see what the heap looks like in one of your passenger threads.</p>

<ul>
<li>Take one of your app servers out of production</li>
<li>Install gdb.rb:</li>
</ul>


<p><code>sudo gem install gdb.rb</code></p>

<ul>
<li>Use <code>sudo passenger-status</code> to find a thread that has handled enough requests to be pretty well warmed up and note its PID.</li>
<li>Connect to the passenger thread with gdb.rb:</li>
</ul>


<p><code>sudo gdb.rb &lt;pid&gt;</code></p>

<ul>
<li>Get gdb.rb to print out the stats about your objects:</li>
</ul>


<p><code>ruby objects</code></p>

<p>You're looking for a section that looks like this:</p>

<pre><code>HEAPS            9
  SLOTS      3061241
  LIVE       1457106 (47.60%)
  FREE       1604135 (52.40%)
</code></pre>

<p>We're going to assume that "LIVE" number is representative of how many slots you normally use up.  Round that up to something sensible like 1,500,000.  Now do the math like this:</p>

<pre><code>RUBY_HEAP_MIN_SLOTS=1800000          # Slots Live + 20%
RUBY_HEAP_FREE_MIN=18000             # 1% of HEAP_MIN_SLOTS
RUBY_HEAP_SLOTS_INCREMENT=144000     # 8% of HEAP_MIN_SLOTS
RUBY_HEAP_SLOTS_GROWTH_FACTOR=1
RUBY_GC_MALLOC_LIMIT=60000000
</code></pre>

<p>I know there's no explanation for those last two settings, but I haven't really explained the math behind the other numbers either.  This is meant to be a good starting point.  Its customized for your app to some degree, but with some assumptions.</p>

<h2>Wrap Your Ruby</h2>

<p>Now create a wrapper script that sets these variables in the environment before calling ruby.  I'm going to assume you put it in <code>/usr/local/bin</code> and call it <code>ruby_tuned</code>.  The file should look like this (make sure you adjust for the path to ruby on your system):</p>

<pre><code>#!/bin/bash

export RUBY_HEAP_MIN_SLOTS=1800000
export RUBY_HEAP_FREE_MIN=18000
export RUBY_HEAP_SLOTS_INCREMENT=144000
export RUBY_HEAP_SLOTS_GROWTH_FACTOR=1
export RUBY_GC_MALLOC_LIMIT=60000000

exec "/usr/local/bin/ruby" "$@"
</code></pre>

<h2>Update Passenger</h2>

<p>Have passenger use your <code>ruby_tuned</code> wrapper instead of calling ruby directly by updating <code>passenger.conf</code> (look in <code>/etc/apache2/mods-enabled</code> on Ubuntu).  You'll want it to look like this:</p>

<pre><code>PassengerRoot /usr/local/lib/ruby/gems/1.8/gems/passenger-3.0.11
PassengerRuby /usr/local/bin/ruby_tuned
</code></pre>

<p>Now restart apache, add the server back into production and check NewRelic to see how you did.</p>

<h2>What We Got</h2>

<p><img src="http://technology.customink.com/images/Response_Time_GC.jpg"></p>

<p>The graph above is from New Relic as I rolled the changes out one server at a time.  When we applied these changes to our first app we saw:</p>

<ul>
<li>Time spent in GC drop from ~35ms per request to ~10ms</li>
<li>CPU usage drop almost in half</li>
<li>A slight increase in memory used</li>
</ul>


<h2>Where Those Numbers Actually Came From</h2>

<p>To understand these settings and what they do checkout:</p>

<ul>
<li><a href="http://www.viddler.com/v/87ae120a">This Presentation from Joe Damato</a></li>
<li><a href="http://www.coffeepowered.net/2009/06/13/fine-tuning-your-garbage-collector/">This Post from Chris Heald</a> (he adds a gem to his app instead of using gdb.rb)</li>
<li><a href="http://www.rubyenterpriseedition.com/documentation.html#_garbage_collector_performance_tuning">The Ruby Enterprise GC documentation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Data Mapper]]></title>
    <link href="http://technology.customink.com/blog/2012/03/02/simple-data-mapper/"/>
    <updated>2012-03-02T15:35:00-05:00</updated>
    <id>http://technology.customink.com/blog/2012/03/02/simple-data-mapper</id>
    <content type="html"><![CDATA[<p>I recently tackled a pretty typical data migration task where some source model had to be transformed into some target model.  About 80% of the elements were mapped field for field, and the other 20% had to be mutated in some way.  Tired of writing one off rake tasks to pull and transform data, I came up with a little data mapper class that I cold reuse in the future.</p>

<p>```ruby
class Mapper
  attr_accessor :source_model
  attr_accessor :mappings</p>

<p>  class AttributeMapping;end</p>

<p>  class ListMapping &lt; AttributeMapping</p>

<pre><code>attr_accessor :fields

# fields - array of field symbols we want to map data into
def initialize(fields)
  self.fields = fields
end

def transform(source_obj, source_attribute)
  {}.tap do |values|
    fields.each do |field|
      values[field] = source_obj.send(source_attribute)
    end
  end
end
</code></pre>

<p>  end</p>

<p>  class ComplexMapping &lt; AttributeMapping</p>

<pre><code>attr_accessor :field
attr_accessor :instruction

# field       - field symbol we want to map data into
# instruction - lambda which accepts source object and source attribute. 
#               expected to return value to be mapped to field (on target obj)
def initialize(field, instruction)
  self.field = field
  self.instruction = instruction
end

def transform(source_obj, source_attribute)
  { field =&gt; instruction.call(source_obj, source_attribute) }
end
</code></pre>

<p>  end</p>

<p>  def initialize(source_model, mappings)</p>

<pre><code>self.source_model = source_model
self.mappings = mappings
</code></pre>

<p>  end</p>

<p>  def conjure(model)</p>

<pre><code>values = map_values_for( self.source_model, self.mappings )
model.to_s.camelize.constantize.new(values)
</code></pre>

<p>  end</p>

<p>  def map_values_for(source_model, mappings)</p>

<pre><code>{}.tap do |values|
  mappings.each do |attr, mapping|
    if AttributeMapping === mapping
      values.update(mapping.transform(source_model, attr))
    else
      values[mapping] = source_model.send(attr)
    end
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Using the mapper is really simple.  Let's say my source model, LegacyCustomer, is based off of a legacy table from an older system and looks like:</p>

<p>```ruby
LegacyCustomer(
  userid: integer,        # primary key
  creationdate: datetime, # date record was created
  accountnum: string      # customer number. it's prefixed with</p>

<pre><code>                      # "LGCY-" string that we no longer need!
</code></pre>

<p>)
```</p>

<p>And we want to migrate the LegacyCustomer data to a new Customer model that looks like:
<code>ruby
Customer(
  id: integer,
  created_at: datetime,
  updated_at: datetime,
  account_number: string
)
</code></p>

<p>My rake task to run the migration would look like:
```ruby
namespace :migrate do
  task :legacy_customers do</p>

<pre><code>field_mappings = {
  :userid         =&gt; :id,
  :creation_date  =&gt; Mapper::ListMapping.new(
                      [:created_at, :update_at]
                     ),
  :user_data      =&gt; Mapper::ComplexMapping.new(
                      :account_number, 
                      lambda {|obj, attr| obj.send(attr).gsub('LGCY-','')}
                     )
}

LegacyCustomer.all.each do |legacy_customer|
  mapper = Mapper.new(legacy_customer, field_mappings)
  customer = mapper.conjure(:customer)
  customer.save!
end
</code></pre>

<p>  end
end
```</p>

<p>As my migration marched on 'one off' data errors would pop up causing the script to fail.  This is what ultimately led me to create the ComplexMapping class.  Every time some white space, funny character, or field split requirement bombed my script I was able to add some code to my ComplexMapping requirement to solve it.</p>

<p>I wanted to share this experience for two reasons:</p>

<p>Ruby is awesome.  Metaprogramming and Procs made this mapper possible.  When I first started programming with Ruby, these were the two hardest concepts for me to wrap my head around.  Investing time into learning these aspects of ruby have made me such a better ruby programmer.</p>

<p>The second reason is to reinforce the lesson that doing things the lazy (comfortable) way will rarely ever benefit you.  This mapper class not only made writing and maintaining my migration script easier.  It has also found it's way into some production code.</p>

<p>Abstracting concepts (or remembering the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>) will always benefit you in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Organizing Your Rails Models]]></title>
    <link href="http://technology.customink.com/blog/2012/02/03/organizing-your-rails-models/"/>
    <updated>2012-02-03T15:38:00-05:00</updated>
    <id>http://technology.customink.com/blog/2012/02/03/organizing-your-rails-models</id>
    <content type="html"><![CDATA[<p>Like people, applications start out small.  Unlike people, applications do not always have a predictable growth pattern.  Sometimes they grow really big, and sometimes not at all.  When applications grow large, organization becomes important because it is no longer possible to remember every detail about your application without consulting the source code.</p>

<p>"We use Rails, the convention tells us how to organize our code".  Yes, but having 50 or more files in your app/models directory is hardly being organized.</p>

<p>A simple thing I like to do is group related models into folders.  This allows you to organize the related models of a domain into a single location while any shared or stand alone models simply remain in the root directory.  For instance, my directory structure may look something like:</p>

<p>```
app
|<em>models
   |</em>address.rb
   |_orders</p>

<pre><code>  |_order.rb
  |_item.rb
  |_shipping_detail.rb
</code></pre>

<p>```</p>

<p>And to make sure Rails can find all of my models, I need to update config/application.rb file as such:</p>

<p><code>ruby
config.autoload_paths += ['app/models/**"]
</code></p>

<p>This allows developers to quickly see what models make up an order and what models either stand on their own, or are shared across multiple domains.  And for a large application, you are now able to quickly summarize the high level business objects that make up your system.</p>
]]></content>
  </entry>
  
</feed>
