<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | EngineerInk]]></title>
  <link href="http://technology.customink.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://technology.customink.com/"/>
  <updated>2012-03-02T16:37:54-05:00</updated>
  <id>http://technology.customink.com/</id>
  <author>
    <name><![CDATA[CustomInk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simple Data Mapper]]></title>
    <link href="http://technology.customink.com/blog/2012/03/02/simple-data-mapper/"/>
    <updated>2012-03-02T15:35:00-05:00</updated>
    <id>http://technology.customink.com/blog/2012/03/02/simple-data-mapper</id>
    <content type="html"><![CDATA[<p>I recently tackled a pretty typical data migration task where some source model had to be transformed into some target model.  About 80% of the elements were mapped field for field, and the other 20% had to be mutated in some way.  Tired of writing one off rake tasks to pull and transform data, I came up with a little data mapper class that I cold reuse in the future.</p>

<p>```ruby
class Mapper
  attr_accessor :source_model
  attr_accessor :mappings</p>

<p>  class AttributeMapping;end</p>

<p>  class ListMapping &lt; AttributeMapping</p>

<pre><code>attr_accessor :fields

# fields - array of field symbols we want to map data into
def initialize(fields)
  self.fields = fields
end

def transform(source_obj, source_attribute)
  {}.tap do |values|
    fields.each do |field|
      values[field] = source_obj.send(source_attribute)
    end
  end
end
</code></pre>

<p>  end</p>

<p>  class ComplexMapping &lt; AttributeMapping</p>

<pre><code>attr_accessor :field
attr_accessor :instruction

# field       - field symbol we want to map data into
# instruction - lambda which accepts source object and source attribute. 
#               expected to return value to be mapped to field (on target obj)
def initialize(field, instruction)
  self.field = field
  self.instruction = instruction
end

def transform(source_obj, source_attribute)
  { field =&gt; instruction.call(source_obj, source_attribute) }
end
</code></pre>

<p>  end</p>

<p>  def initialize(source_model, mappings)</p>

<pre><code>self.source_model = source_model
self.mappings = mappings
</code></pre>

<p>  end</p>

<p>  def conjure(model)</p>

<pre><code>values = map_values_for( self.source_model, self.mappings )
model.to_s.camelize.constantize.new(values)
</code></pre>

<p>  end</p>

<p>  def map_values_for(source_model, mappings)</p>

<pre><code>{}.tap do |values|
  mappings.each do |attr, mapping|
    if AttributeMapping === mapping
      values.update(mapping.transform(source_model, attr))
    else
      values[mapping] = source_model.send(attr)
    end
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Using the mapper is really simple.  Let's say my source model, LegacyCustomer, is based off of a legacy table from an older system and looks like:</p>

<p>```ruby
LegacyCustomer(
  userid: integer,        # primary key
  creationdate: datetime, # date record was created
  accountnum: string      # customer number. it's prefixed with</p>

<pre><code>                      # "LGCY-" string that we no longer need!
</code></pre>

<p>)
```</p>

<p>And we want to migrate the LegacyCustomer data to a new Customer model that looks like:
<code>ruby
Customer(
  id: integer,
  created_at: datetime,
  updated_at: datetime,
  account_number: string
)
</code></p>

<p>My rake task to run the migration would look like:
```ruby
namespace :migrate do
  task :legacy_customers do</p>

<pre><code>field_mappings = {
  :userid         =&gt; :id,
  :creation_date  =&gt; Mapper::ListMapping.new(
                      [:created_at, :update_at]
                     ),
  :user_data      =&gt; Mapper::ComplexMapping.new(
                      :account_number, 
                      lambda {|obj, attr| obj.send(attr).gsub('LGCY-','')}
                     )
}

LegacyCustomer.all.each do |legacy_customer|
  mapper = Mapper.new(legacy_customer, field_mappings)
  customer = mapper.conjure(:customer)
  customer.save!
end
</code></pre>

<p>  end
end
```</p>

<p>As my migration marched on 'one off' data errors would pop up causing the script to fail.  This is what ultimately led me to create the ComplexMapping class.  Every time some white space, funny character, or field split requirement bombed my script I was able to add some code to my ComplexMapping requirement to solve it.</p>

<p>I wanted to share this experience for two reasons:</p>

<p>Ruby is awesome.  Metaprogramming and Procs made this mapper possible.  When I first started programming with Ruby, these were the two hardest concepts for me to wrap my head around.  Investing time into learning these aspects of ruby have made me such a better ruby programmer.</p>

<p>The second reason is to reinforce the lesson that doing things the lazy (comfortable) way will rarely ever benefit you.  This mapper class not only made writing and maintaining my migration script easier.  It has also found it's way into some production code.</p>

<p>Abstracting concepts (or remembering the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>) will always benefit you in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Organizing Your Rails Models]]></title>
    <link href="http://technology.customink.com/blog/2012/02/03/organizing-your-rails-models/"/>
    <updated>2012-02-03T15:38:00-05:00</updated>
    <id>http://technology.customink.com/blog/2012/02/03/organizing-your-rails-models</id>
    <content type="html"><![CDATA[<p>Like people, applications start out small.  Unlike people, applications do not always have a predictable growth pattern.  Sometimes they grow really big, and sometimes not at all.  When applications grow large, organization becomes important because it is no longer possible to remember every detail about your application without consulting the source code.</p>

<p>"We use Rails, the convention tells us how to organize our code".  Yes, but having 50 or more files in your app/models directory is hardly being organized.</p>

<p>A simple thing I like to do is group related models into folders.  This allows you to organize the related models of a domain into a single location while any shared or stand alone models simply remain in the root directory.  For instance, my directory structure may look something like:</p>

<p>```
app
|<em>models
   |</em>address.rb
   |_orders</p>

<pre><code>  |_order.rb
  |_item.rb
  |_shipping_detail.rb
</code></pre>

<p>```</p>

<p>And to make sure Rails can find all of my models, I need to update config/application.rb file as such:</p>

<p><code>ruby
config.autoload_paths += ['app/models/**"]
</code></p>

<p>This allows developers to quickly see what models make up an order and what models either stand on their own, or are shared across multiple domains.  And for a large application, you are now able to quickly summarize the high level business objects that make up your system.</p>
]]></content>
  </entry>
  
</feed>
